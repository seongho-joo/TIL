# JPA 영속성 컨텍스트와 플러시
> 인프런 자바 ORM 표준 JPA 프로그래밍 - 기본편 강의 내용 정리
___
## 영속성 컨텍스트
영속성 컨텍스트란 '엔티티를 영구 저장하는 환경'이라는 뜻이다. 애플리케이션과 DB 사이에서 객체를 보관하는 논리적 개념이다.
엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

`em.persist`
- DB에 저장한다는 뜻이 아닌 엔티티를 영속성 컨텍스트에 저장한다는 의미

**특징**
- 엔티티 매니저를 생성할 때 딱 하나만 만들어진다.
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근하고 관리할 수 있다.

## 엔티티의 생명주기
![](https://user-images.githubusercontent.com/45463495/162735775-ac2a5586-446d-43eb-830e-e5e3de0f2a81.png)
- 비영속(new/transient)
  - 영속성 컨텍스트와 전혀 관계가 없는 **새로운** 상태
- 영속(managed)
  - 영속성 컨텍스트에 **관리**되는 상태
- 준영속(detached)
  - 영속성 컨텍스트에 저장되었다가 **분리**된 상태
- 삭제(removed)
  - **삭제**된 상태

### 비영속
엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장하지 않은 상태
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1")
```

### 영속
엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태
```java
em.persist(member);
```

### 준영속
엔티티를 영속성 컨텍스트에서 분리, 준영속 상태   
영속성 컨텍스트가 제공하는 기능을 사용 못함
```java
// 특정 엔티티만 준영속 상태로 전환
em.detach(member);
// 영속성 컨텍스트를 완전히 초기화
em.clear()
// 영속성 컨텍스트를 종료
em.close()
```

### 삭제
엔티티를 영속성 컨텍스트와 DB에서 삭제
```java
em.remove(member);
```

## 영속성 컨텍스트의 특징
한 트랜잭션 범위에서만 관리할 수 있고 트랜잭션이 끝나면 사라진다.

영속성 컨택스트의 이점
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### 1차 캐시
영속성 컨텍스트 내부에 존재하는 캐시를 말한다. 영속 상태의 엔티티를 이곳에 저장하며, 1차 캐시의 key는 `PK`이고 value는 entity 인스턴스이다.

`em.find`의 과정
- 1차 캐시에서 엔티티를 찾는다.
- 해당 엔티티가 있으면 엔티티를 반환한다.
- 만약 존재하지 않는다면, 데이터베이스에 엔티티가 있다는 가정하에 데이터베이스에서 조회한다.
- 조회한 엔티티를 1차 캐시에 저장하고 반환한다.

### 동일성 보장
영속성 컨텍스트는 엔티티의 동일성을 보장한다.
```java
Member a = em.find(Member.calss, "member1");
Member b = em.find(Member.calss, "member1");

System.out.println(a == b); // true
```

### 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
`em.persist` 를 사용할 때마다 SQL을 DB에 보내지 않고 트랜잭션 commit 시점에 쿼리를 DB에 보내는 것을 말한다.
```java
EntityManger em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();

tx.begin(); // 트랜잭션 시작

em.persist(member1);
em.persist(member2);

tx.commit(); // 트랜잭션 커밋
// 커밋하는 시점에 DB 쿼리를 보냄
```

### 변경 감지(dirty checking)
자바 컬렉션을 사용하듯이 엔티티를 조회해서 데이터를 변경하면 JPA가 알아서 DB에 update 쿼리를 보낸다.

**변경 감지의 동작 원리**
1. 트랜잭션을 커밋하는 시점에 엔티티 매니저 내부에서 `flush`가 호출된다.
2. 엔티티와 스냅샵을 비교하여 변경된 엔티티를 찾는다.
3. 변경된 엔티티가 있다면 update 쿼리를 쓰기 지연 SQL 저장소에 저장한다.
4. 쓰기 지연 저장소의 SQL을 플러시 한다.
5. DB 트랜잭션을 커밋한다.

## 플러시(flush)
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것을 뜻한다. **플러시가 발생하더라도 영속성 컨텍스트는 지워지지 않는다.**

**플러시의 발생**
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰지 지연 SQL 저장소의 쿼리들을 DB에 전송

영속성 컨텍스트를 플러시하는 방법
- `em.flush()`
- 트랜잭션 커밋
- JPQL 쿼리 실행

플러시 모드 옵션
- AUTO: 커밋이나 쿼리를 실행할 때 플러시(defualt)
- COMMIT: 커밋할 때만 플러시